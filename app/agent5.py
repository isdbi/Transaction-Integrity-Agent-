import os
import json
from langchain.embeddings import OpenAIEmbeddings
import pinecone
from pinecone import ServerlessSpec
from langchain.vectorstores import Pinecone as LangchainPinecone
from langchain.chat_models import ChatOpenAI
from langchain.chains import RetrievalQA
from langchain.prompts import PromptTemplate


def calculate_mudarabah_musharakah(investments, profits, loss_share_ratios):
    """
    investments: dict of partner -> invested capital
    profits: total profit amount
    loss_share_ratios: dict of partner -> loss share ratio (proportional to capital)
    Returns profit distribution and loss allocation.
    """
    total_capital = sum(investments.values())
    # Profit distribution according to agreed ratios
    profit_distribution = {p: round(profits * ratio, 2) for p, ratio in loss_share_ratios.items()}
    # Loss allocation proportional to capital
    loss_allocation = {p: round((investments[p] / total_capital) * abs(loss_share_ratios.get(p, 0)), 2) for p in investments}
    return {"profit_distribution": profit_distribution, "loss_allocation": loss_allocation}


def calculate_murabaha(cost, profit_rate, time_period_years):
    """
    cost: base cost
    profit_rate: annual profit rate (e.g., 0.1 for 10%)
    time_period_years: time in years for deferred payment
    """
    profit = round(cost * profit_rate * time_period_years, 2)
    total_price = round(cost + profit, 2)
    return {"markup": profit, "total_price": total_price}


def calculate_ijarah(asset_cost, rental_rate, lease_periods):
    """
    asset_cost: cost of asset
    rental_rate: periodic rental rate (e.g., 0.05 per period)
    lease_periods: number of periods
    """
    lease_payments = round(asset_cost * rental_rate * lease_periods, 2)
    return {"lease_payments": lease_payments}


def calculate_zakat(qualifying_assets_total):
    """
    qualifying_assets_total: sum of assets subject to Zakat
    """
    zakat_due = round(qualifying_assets_total * 0.025, 2)
    return {"zakat_due": zakat_due}


def calculate_qard_hasan(principal, charges=0):
    """
    principal: loan amount
    charges: any additional fee
    Returns whether any interest applied.
    """
    interest_applied = charges > 0
    return {"interest_applied": interest_applied, "principal": principal}


def calculate_sukuk(profits, asset_value):
    """
    profits: profits generated by underlying asset
    asset_value: nominal value of the asset pool
    """
    # Profit distribution proportional to asset value
    return {"profit_distribution": profits, "asset_ownership": asset_value}


def setup_transaction_integrity_chain(
    index_name: str = "accounting_rules",
    pinecone_region: str = "us-east-1",
    openai_api_key: str = None,
    pinecone_api_key: str = None
):
    """
    Initialize the Transaction Integrity Agent chain.

    - Loads AAOIFI and IFRS mapping documents into Pinecone.
    - Prepares a prompt to check transaction logs for mismatches, fraud risks, and standard violations.
    """
    openai_key = openai_api_key or os.getenv("OPENAI_API_KEY")
    pinecone_key = pinecone_api_key or os.getenv("PINECONE_API_KEY")
    if not openai_key or not pinecone_key:
        raise ValueError("OPENAI_API_KEY and PINECONE_API_KEY must be set")
    os.environ["OPENAI_API_KEY"] = openai_key

    embeddings = OpenAIEmbeddings(model="text-embedding-ada-002")

    pc = pinecone.Pinecone(api_key=pinecone_key)
    if index_name not in [idx.name for idx in pc.list_indexes()]:
        pc.create_index(
            name=index_name,
            dimension=1536,
            metric="cosine",
            spec=ServerlessSpec(cloud="aws", region=pinecone_region)
        )

    index = pc.Index(index_name)
    vectorstore = LangchainPinecone(index, embeddings.embed_query, "text")
    retriever = vectorstore.as_retriever(search_type="similarity", search_kwargs={"k": 5})

    prompt = PromptTemplate(
        input_variables=["context", "transactions"],
        template="""
You are an AI specialized in Islamic bank transaction integrity, combining AAOIFI and IFRS accounting standards.

Tasks:
1. Identify value mismatches or inconsistencies in the transaction entries.
2. Flag any entries that pose fraud or money-laundering risks.
3. Detect violations of Shariah accounting standards or IFRS mappings.
4. Perform the following calculations and validations:
   - Profit and Loss Sharing: Verify profit distribution and loss allocation in Mudarabah and Musharakah contracts.
   - Murabaha: Calculate markup and total price; ensure fixed profit margins.
   - Ijarah: Compute lease payments; confirm ownership transfer where applicable.
   - Zakat: Calculate 2.5% on qualifying assets held over one lunar year.
   - Qard Hasan: Ensure no interest or additional charges.
   - Sukuk: Validate profit distribution based on asset performance and ownership representation.

Return JSON:
{
  "value_mismatches": ["description1", ...],
  "fraud_risks": ["description2", ...],
  "standard_violations": ["violation1", ...],
  "calculations": {
    "mudarabah_musharakah": {"profit_distribution": ..., "loss_allocation": ...},
    "murabaha": {"markup": ..., "total_price": ...},
    "ijarah": {"lease_payments": ...},
    "zakat": {"zakat_due": ...},
    "qard_hasan": {"interest_applied": ..., "principal": ...},
    "sukuk": {"profit_distribution": ..., "asset_ownership": ...}
  },
  "suggestions": ["suggestion1", ...]
}

Transaction Logs:
{transactions}

Relevant Accounting Rules:
{context}
"""
    )

    qa_chain = RetrievalQA.from_chain_type(
        llm=ChatOpenAI(temperature=0),
        retriever=retriever,
        chain_type="stuff",
        chain_type_kwargs={"prompt": prompt},
        return_source_documents=True
    )

    return qa_chain


def analyze_transactions(
    transactions: str,
    qa_chain,
    output_path: str = "transaction_integrity_result.json"
):
    """
    Analyze transaction logs against accounting standards.
    """
    result = qa_chain.invoke({"query": transactions})
    raw = result.get("result")
    try:
        output = json.loads(raw)
    except json.JSONDecodeError:
        output = {"error": "Invalid JSON from model", "raw": raw}

    # Optionally, apply local calculation functions if missing
    if output.get("calculations"):
        calc = output["calculations"]
        # Example: if murabaha missing, compute via local function placeholders
        # This assumes transactions contain parsed fields; adapt as needed.
        # output["calculations"]["murabaha"] = calculate_murabaha(cost, rate, period)

    with open(output_path, "w", encoding="utf-8") as f:
        json.dump(output, f, indent=4, ensure_ascii=False)
    print(f"Saved transaction integrity result to {output_path}")
    return output


if __name__ == "__main__":
    chain = setup_transaction_integrity_chain()
    sample_logs = open("sample_transactions.csv", "r").read()
    result = analyze_transactions(sample_logs, chain)
    print(result)
